#  面经

[TOC]



### HTML

- meta标签里有什么 什么作用

- herf 和 src 的区别：

  >href 标识超文本的引用，用在 link 和 a标签上， herf 是是引用和页面关联，是在当前元素和引用资源之间建立联系；
  >
  >
  >
  >src 表示引用资源替换当前元素，用在 img，iframe 上，是页面中不可或缺的部分；
  >
  >src是source的缩写，是指向外部资源的位置，指向的内部会迁入到文档中当前标签所在的位置；在请求src资源时会将其指向的资源下载并应用到当前文档中，例如js脚本，img图片和frame等元素。
  >
  >`<script src='javascript.js'> </script>` 当浏览器解析到这一句的时候会暂停其他资源的下载和处理，直至将该资源加载，编译，执行完毕，图片和框架等元素也是如此，类似于该元素所指向的资源嵌套如当前标签内，这也是为什么要把js脚本放在底部而不是头部。
  >
  >`<link href="common.css" rel="stylesheet"/>` 当浏览器解析到这一句的时候会识别该文档为 css 文件，会下载但是不会停止对当前文档的处理，这也是为什么建议使用 link 方式来加载 css 而不是使用 @import。

  

- link 和 @import 的区别

  1. link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS；

  2. link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载；

  3. link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。

  4. link支持使用Java控制DOM去改变样式；而@import不支持。

     

- HTML5新增（主要是标签什么的）
  1. 语义化标签 `<Nav>、<header>、<footer>、<aside>、<article>`
  2. 新增了视频、音频api
  3. 新增了 canvas 的api
  4. 新增了表单控件 ：`calender | data | time | email | url | search`;
  5. 新增本地储存：`localStorage | sessionStorage`;
  6. 新技术 `webworker | websocket`
  7. 删除基础元素 `big | font | center`
  8. 删除对可用性产生负面影响的：`frame | frameset | noframes`

### css

- CSS选择器的类型和权重

  1. id选择器
  2. className选择器，属性选择器，伪类选择器；
  3. 标签选择器，伪元素选择器；
  4. 后代选择器，子选择器，兄弟选择器；

  优先级排序：**!important > 行内样式>ID选择器 > 类选择器 > 标签 > 通配符 > 继承 > 浏览器默认属性**

  

- CSS渲染的详细过程？

- 哪些css属性会导致重排？

- translate 3d 和 flex 在渲染上有什么不同的地方？

- flex:1 是什么意思？

  

- 垂直居中和水平居中的几种方式

- `position` 的属性

- BCF

- CSS盒模型

  > 常见的 div、a、span都是盒模型，但表单元素，图片这些自闭合标签，不能算做盒模型；
  >
  > 盒模型主要区域：`width、height、padding、border、margin`；
  >
  > `真实占有宽度 = 左border + 左padding + width + 右padding + 右border`
  >
  > 在标准的盒模型中，`width` 就是 `content` 的宽度；
  >
  > 在 IE 盒模型中，`width` 是 `content + padding + border`
  >
  > 可使用 `box-sizing` 来设置盒子遵循的模型：`border-box(IE盒模型)、content-box(标准盒模型, 默认值)`

- flex布局

  >传统的布局方案，以来 `display` 属性 + `position` 属性 + `float` 属性来实现，但是书写起来比较麻烦，对于特殊的布局也不方便，因此提出 flex 布局；
  >
  >一般情况下，我们给父盒子设置 `flex`，也就是将其作为 `flex` 容器，该容器中的每一个子元素都作为 `flex item`；
  >
  >
  >
  >父盒子 (flex 容器)：
  >
  >该容器含有两个轴：水平的主轴 (main start) 和 垂直的交叉轴 (cross start)；
  >
  >其含有六个属性：
  >
  >- flex-direction (item排列方向)：`row | row-reverse | column | column-reverse`
  >
  >- flex-wrap (换行问题)：`nowrap | wrap | wrap-reverse`
  >
  >- flex-flow (上两者的简写)：`<flex-direction> || <flex-wrap>`
  >
  >- justify-content (主轴对齐方式)：`flex-start | flex-end | center | space-between(两端对齐，项目之间间隔相等) | space-around(项目两侧间隔相等)`
  >
  >- align-items (交叉轴上对齐方式)：`flex-start | flex-end | center | baseline | stretch`
  >
  >- align-content (多根轴线对齐方式)：`flex-start | flex-end | center | space-between | space-around | stretch`
  >
  >
  >
  >子盒子 (item 属性)：
  >
  >六个属性：
  >
  >- order (item排列方式)：`数值`
  >- flex-grow (默认放大比例)：`默认0, 表默认不放大`
  >- flex-shrink (默认缩小比例)：`默认1, 表默认缩小`
  >- flex-basis (分配多余空间前，项目占据的主轴空间)：`默认为auto`
  >- flex (前三者的简写)：`0 1 auto | 1 1 auto(auto) | 0 0 auto(none)`
  >- align-self (单个项目有不同的对齐方式)：`auto | flex-start | flex-end | center | baseline | stretch`

- `grid` 布局

  >采用网格布局的区域称为**容器(`container`)**，容器内部采用网格定位的子元素，称为**项目(`item`)**；
  >
  >````html
  ><div>
  ><div><p>1</p></div>
  ><div><p>2</p></div>
  ><div><p>3</p></div>
  ></div>
  >````
  >
  >上述代码中，最外层的 `div` 就是容器，内层的三个 `div` 就是项目；
  >
  >**注意**：项目只能是容器顶层的子元素，不包含项目的子元素，比如上面的 `p` 元素就不是项目，`grid` 布局只对项目生效；
  >
  >
  >
  >在 容器中 水平的统称为行，竖直的统称为列，行和列的交叉区域称为单元格，n行和m列会产生 m x n个单元格；
  >
  >划分网格的线，被称为网格线水平网格划分出行，垂直网格划分为列，grid容器也分为容器属性和项目属性两类；
  >
  >
  >
  >容器(contain)：
  >
  >设置了 `display: grid/inline-grid` 的盒子称为容器；
  >
  >- `grid-template-columns/grid-template-rows`：定义每一列的列宽/行高(可以使用百分比 或者 px 或 `repeat(3, 33.3%)` 或 auto-fill 或 fr 或 auto 或 maxmin(min, max) )
  >- `row-gap/column-gap/gap`：定义 行/列 之间的间隔 (px)
  >- `grid-template-areas`：网格布局允许指定区域，一个区域由单个或多个单元格组成，区域的命名会影响网格线，每个区域的 起始/结束 网格线会自动命名为 `区域名-start/区域名-end`
  >- `grid-auto-flow`：定义项目的排列顺序，先行后列/先列后行/某些项目位置指定后剩下的项目自动放置(row/column/row-dense/column-dense)
  >- `justify-items/align-items/place-items`：调整**单元格内容的位置** (`start/end/center/stretch(默认)`)
  >- `justify-content/align-content/place-content`：调整**整个内容区域在容器中的位置**(`start/end/center/stretch/space-around/space-between/space-evenly`)
  >- `grid-auto-columns/grid-auto-rows`：用来指定浏览器自动生成多余网格的行宽列高(px)；
  >- `grid/grid-template`：合并写法，但最好不要使用；
  >
  >
  >
  >项目(item)：
  >
  >在容器顶层的子元素；
  >
  >- `grid-column-start/grid-column-end/grid-row-start/grid-row-end`：类似于指定项目边框，指定项目开始位置和结束位置(数值 或 网格线名字 或 span+数值)；
  >- `grid-column/grid-row`：是一样两种形式的简写(<start-line> / <end-line>)；
  >- `grid-area`：指定项目位于哪一个区域(区域名/以上四种属性的简写)；
  >- `justify-self/align-self/place-self`：设置单元格内容的 水平/垂直 位置 (start/end/center/stretch)；
  >
  >**注意**：设置为网格布局后，容器子元素项目(item)的 `float、display: inline-block/table-cell、vertical-align、column-*` 都将失效；

- flex 和 grid 的区别 

  > flex 布局是轴线布局，只能指定 `item` 针对周线的位置，可以看作是一种一维布局；
  >
  > grid 布局则是将容器划分为行和列，产生单元格，然后指定 `item` 所在单元格，可以看作是二维布局，相对 flex 布局更为强大，其将网页划分为一个个网格，可以任意组合不同网格，对网页进行布局；

- 两栏布局（左栏固定宽度 右栏自适应）有几种方法

  

### JS 及 ES6

- 具名函数

  ````js
  var a = 10;
  (function a(){
      a = 20;
      console.log(this.a);	// 10
      console.log(a);			// function a() {a = 20; console.log(a)}
  }())
  ````

  上面输出的 10 很好理解，因为 IIEF 执行的上下文就是 `window` 那么此时读取 `this.a` 就是外部定义的 `a = 10`；

  而 `a` 输出的 `function a` 就涉及到具名函数的知识点，即：

  这是一个立即执行的函数表达式（Immediately-invoked function expression, IIFE），更特殊的，该函数表达式是一个具名函数表达式（Named function expression, NFE)，NFE 两大特性：

  - 作为函数名的标识符（在这里是 `a` ）只能从函数体内部访问，在函数外部访问不到 (IE9+)；
  - 绑定为函数名的标识符（在这里是`a`）不能再绑定为其它值，即该标识符绑定是不可更改的（immutable），所以在 NFE 函数体内对 `A` 重新赋值是无效的；

  ````js
  var a = 10;
  function a() {
      console.log(a);
  }
  console.log(a);		// 10
  a();				// 报错：a不可调用
  ````

  出现这样的原因就是因为若函数不是赋值表达式的形式 那么该函数名只有在函数被调用时才会初始化赋值，否则不会；

  但若不写 `var a = 10` 这条赋值语句，会输出：

  ````js
  function a() {
      console.log(a);
  }
  console.log(a);		// function a
  ````

  这是js的一个类似保护机制，若一个变量没有声明，没有赋值，但有一个函数将其定义为自身函数名，则不输出 undefined，输出该函数；

  

- `for in` 和 `for of` 的区别

  > for in ：可以用来遍历数组或者对象的属性，该循环是。。。的内置方法，在原型链中被继承，只遍历可枚举属性，在遍历数组时，数组的索引只是具有整数名称的可枚举属性，并且与通用对象属性相同，**因此不能保证 for in 以任何特定的顺序返回索引**，因为迭代的顺序是依赖于执行环境的，所以数组遍历不一定按次序访问元素。因此当迭代访问顺序很重要的数组时，最好用整数索引去进行`for`循环（或者使用 `Array.prototype.forEach()` 或 `for...of` 循环）。
  >
  > 
  >
  > for of :是ES6新特性，用来遍历可迭代对象，例如`Array`，`Map`，`Set`，`String`，`TypedArray`，`arguments` 之类的，一个数据结构只要部署了 Symbol.iterator 属性, 就被视为具有 iterator接口, 就可以使用 for of循环。
  >
  > 
  >
  > 简单来说两者有以下区别：
  >
  > 1. for of无法循环遍历对象；
  >
  > 2. 遍历输出结果不同，for in循环遍历的是数组的键值(索引)，而for of循环遍历的是数组的值；
  >
  > 3. for in 会遍历自定义属性，for of不会
  >
  >    ````js
  >    var arr = ['nick','freddy','mike','james'];
  >    arr.name = "数组";
  >                                                                                                                                                                       
  >    for(var key in arr){
  >        console.log(key+': '+arr[key]);	
  >    }
  >    console.log('-----------分割线-----------');
  >    for(var item of arr){	
  >        console.log(item);
  >    }
  >    ````
  >
  >    输出结果：for in输出自定义属性name，而for of没有
  >
  >    ![20180531124338420](20180531124338420.png)

  

- `promise`

  >`Promise` 是异步操作的解决方案，一般用来**解决层层嵌套** (回调地狱 callback hell)  的回调函数；
  >
  >
  >
  >在实例化一个Promise时，必须传一个回调函数作为参数，该函数接收 `resolve/reject` 作为参数，在该函数中调用这两个参数作为函数，则可以改变Promise的状态；
  >
  >
  >
  >`Promise` 的三 个状态：
  >
  >- `pending`：初始态
  >- `fullfilled / resolved`：成功态
  >- `rejected`：失败态
  >
  >**Promise 的状态一旦变化就不会再改变**;
  >
  >
  >
  >Promise有一个 `then()` 方法，该方法参数为两个回调函数，在Promise为成功态时执行第一个回调，失败态时执行第二个回调，同时，then() 方法中可以接收 `resolve() 和 reject()` 中传的参数，在 `then()` 执行完成后 retrun 一个新的 Promise 对象；
  >
  >若不写 return 则直接返回一个成功态的 Promise；
  >
  >若 return new Promise()，则终止 链式then() 的执行； 
  >
  >
  >
  >`catch()` 方法：
  >
  >一般情况下，`then()` 方法被用来处理 `resolve()` 的状态，而当出现异常时我们一般不去调用 `then()` 方法的第二个回调函数，而是使用 `catch()` 处理出现的异常；如果一个异常没有被捕获，那么他将会一直向下传递直至被捕获为止；其实 `catch()` 算是一种特殊的 `then()`；
  >
  >
  >
  >Promise的其他方法
  >
  >- `finally()` 方法：表达一个 `Promise` 的状态，若变化则会调用该方法，不变则不调用； 
  >
  >- `Promise.resolve() / Promise.rejecte()` ：类似于构造函数 `Promise` 的简写形式；
  >
  >`Promise.resolve()` 参数的三种形式：
  >
  >1. 一般参数：原封不动的向后传递；
  >
  >2. 一个 `Promise` 对象作为参数：
  >
  >   ````js
  >   const p1 = new Promise(() => {
  >       setTimeout(console.log, 2000, 'OK');
  >       // 该写法形同
  >       // setTimeout(() => {
  >       //     console.log('OK');
  >       // }, 2000)
  >   });
  >   Promise.resolve(p1).then(() => {
  >       console.log('end');
  >   });
  >   // 2s后输出OK，但不输出end
  >   // 因为以上的写法就等同于
  >   p1.then();
  >   ````
  >
  >   因此可知，当 Promise 作为参数传入时，等同于 参数Promise 直接调用 `then()`;
  >
  >3. 当一个含有 `then()` 方法的对象传入时：
  >
  >   ````js
  >   const obj = {
  >       then() {
  >           console.log('ending');
  >       }
  >   }
  >   Promise.resolve(obj).then(() => {
  >       console.log('then');
  >   });
  >   // 输出 ending
  >   ````
  >
  >   传入对象的 `then()`，将 `promise` 中原本的 `then()` 覆盖
  >
  >- `Promise.all()`：同时监听多个 `Promise` 对象的状态

  

- 原型链

  

- 作用域与闭包

  闭包：是函数本身和该函数声明时所处的环境状态的组合；

  ![image-20210308194332246](image-20210308194332246.png)

  简而言之，函数能够<u>记住其**定义时**所处的环境</u>，即使函数不在其定义的环境中被调用，也能访问自身定义时所处的变量；

  ````js
  function fun() {
      var name = '慕课网';
      function innerFun() {
          alert(name);
      }
      return innerFun;
  }
  var inn = fun();
  var name = 'imooc';
  inn();      // 调用inn()，警告框弹出'慕课网'，而不是undefined
  ````

  - 为什么 `inn()` 执行后弹出的警告框为 '慕课网' ？

    错误理解：按照正常情况 `inn = innerFun()`，这是把 `fun()` 的内部函数放在外部调用，这样其实是无法获取到 `Fun()` 内部设置的局部变量 `name = '慕课网'` 的值的，因此输出 `imooc` ;

    但是，js中有一个**闭包原则**，由于闭包原则`innerFun()` 定义在 `Fun()` 闭包环境中，因此它能记住 `Fun()` 的环境，使用`inn()` 调用 `innerFun()`时，可以获取到 `Fun()` 中定义的局部变量 `name = '慕课网'`；

  另外，闭包有记忆性，闭包产生时，函数所处的环境状态 (活动对象) 会始终保存在内存中，不会在外部函数调用后被自动清除；

  ````js
  // 闭包常见面试题
  var data = [];
  
  for (var i = 0; i < 3; i++) {
    data[i] = function () {
      console.log(i);
    };
  }
  
  data[0]();		// 3
  data[1]();		// 3
  data[2]();		// 3
  // 因为在循环完成之后 i = 3， 此时再调用函数返回的一定都是 3
  
  // 解决方法一：
  for (let i = 0; i < 3; i++) {
    data[i] = function () {
      console.log(i);
    };
  }
  // 解决方法二：
  for (var i = 0; i < 3; i++) {
    data[i] = (function(i) {
        function () {
          console.log(i);
        };
    })(i)
  }
  ````

  ````js
  // 闭包常见面试题二：实现无限相加add(1)()
  ````

  

  

- 执行上下文

  >它定义了变量或函数有权访问的其它数据，决定了他们各自的行为。每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。
  >
  >函数的上下文是由函数的调用决定的：

  ![image-20210303214725221](image-20210303214725221.png)

  

- 作用域链和上下文

  >每个函数调用时都会产生自己的上下文，即this的指向；当代码执行流进入函数时，函数的上下文被推入一个上下文栈中，一旦函数执行完毕，则上下文栈弹出该上下文，将控制权还给前一个执行的上下文，因此每次代码执行时访问的始终是上下文栈最前端的上下文；
  >
  >上下文代码在执行时，会创建变量对象的一个**作用域链**，这个作用域链决定了各级上下文中的代码在访问遍历和函数的顺序，每次代码执行时访问的始终是上下文栈最前端的上下文，如果上下文为函数，则其活动对象用作变量对象，活动对象最初只有一个定义变量 (argument)，作用域链中的下一个变量对象包含来自上下文，再下一个对象来自再下一个包含上下文，以此类推直至全局上下文，全局上下文始终为作用域链的最后一个变量对象；
  >
  >其实函数作用域链就是一个沿着作用域一层层查找变量的过程，变量的作用域就是一个变量可使用的范围，像是ES6中新提出的let，const声明的变量就是在块级作用域中的；最外层的作用域叫全局作用域，还有函数声明的叫函数例如每声明一个函数就会创建出一个独立的作用域，其中函数可以嵌套，嵌套的函数也就形成了一个作用域链；
  >
  >在作用域中是有遮蔽效应的，如果在自身作用域和上层作用域中同时定义了 a 变量，那么会优先使用自身作用域的 a 变量的值；

  ````js
  function fn(callback){
      var age = 20;
      callback();
  }
  fn(function(){
      console.log(age);//报错
      //1.在当前作用域没有查找到age
      //2.查找上一级作用域：全局作用域
      //为何是全局作用域？因为看上一级作用域，不是看函数在哪调用，而是看函数在哪编写的。
      //这种特别的作用域，叫做“词法作用域”
  })
  ````

  **注意：**函数的上级作用域取决去它在何处编写，而不是在何处被调用，也就是词法作用域；而 this 的指向取决于动态作用域，即函数被执行时所在的位置；

  

- `call(), apply(), bind()`：三者均是用来重新定义 this指向 的

  不同点：

  1. bind() 的返回值是一个新的函数，另外两个则是直接改变调用者的 this，返回值取决于调用者的 `retrun`；
  2. `call() 和 bind()` 传的参数是单个传入，用逗号分隔，而 `apply()`  是以数组的形式将参数传入；

  

- 为什么会变量提升

  - 先从函数提升讲起

    1. 允许声明前调用

       ````js
       function addTwo(x) { return addOne(addOne(x)) } // 能够调用后面的addOne函数
       function addOne(x) { return x + 1 } // 想要调用addTwo也是可以的
       ````

    2. 明确自我递归的语意（`let rec`）

       ````js
       function fib(n) { return n == 2 ? 1 : n == 1 ? 1 : fib(n - 1) + fib (n - 2) } 
       // 由于fib声明提升了，所以无论是let还是let rec，很明白地，fib指的都是自己
       ````

    3. 比较适合解释器分析程序

       因为函数提升到了block前面，所以解释器可以集中地了解到这个block里有哪些函数，然后进行一些准备操作。这类似于一种Top-Down的思想。
       
       

    例题：

    ````js
    var x = 1, y = z = 0;
    function add(n) {
        n = n + 1;
    }
    y = add(x);
    function add(n) {
        console.log(n)
        x = n + 3;
    }
    z = add(x);
    console.log(x ,y, z)
    ````

    注意：`x = 7` 因为函数的声明提升会直接将上一个覆盖 无论调用在哪里，调用的都是最后的 add();

    

  - 至于var变量提升的作用

    根据Brendan Eich本人的说法，这是函数提升的一个"unintended consequence"

    …行吧，果然是个神奇的语言。不过这样做的好处和函数提升的第三点是一样的——集中处理变量声明，并且关联作用域。

    ````js
    // 简述产生此结果的理由
    (function(){
        var x = y = 1;
    })();
    console.log(y);		// 1
    console.log(x);		// x is not defined;
    ````
    
    连等操作符的赋值顺序是由右至左的，因此可以看作赋值过程为 `y = 1, var x = y`，可以看出 x 是由 var 声明并赋值的，为一个IIEF函数中的一个局部变量，而 `y = 1` 是没有任何声明标识符直接赋值的，是一个全局变量，因此在IIEF函数执行结束之后， x 变量被销毁，而 y 变量保存在全局中可以被读取；
    
    ````js
    var a = { n: 1 };
    var b = a;
    // 1. 先将a指向了一个新对象的引用，即 a = {n: 2}
    // 2. 将原来的 a = {n：1} 的a.x赋值为一个对象，即 a.x = {n：2}
    a.x = a = { n: 2 };
    console.log(a);			// {n: 2}
    console.log(b);			// {n: 1, X: {n: 2}}
    ````
    
    **注意**：
    
    - 因为 `.` 的优先级高于 `=`，因此在连等中 a.x 中的 a 并不是引用改变之后的 a，此时堆内存中的 `{n: 1}` 就会变为 `{n: 1, x: undefined}`，则 `b` 指向的堆内存被改变了；
    
    - 赋值操作是从右至左，因此先执行 `a = {n: 2}`，则 `a` 的引用被改变，后将返回值赋堆内存中的 `{n: 1, x: undefined}`，变为 `{n: 1, x: {n: 2}}`
    
      
    
    ````js
    if (!('a' in window)) {
        var a = 10;
        console.log(a);
    }
    ````
    
    在这道题中 `if` 中的语句就不会被执行，因为 `var` 已经将变量 `a` 声明提升了，只是还没有进行初始化赋值而已，因此此时 `'a' in window` 的值是 `true`；
    
    

- var、let、const

  >`var`：
  >
  >声明的变量会被自动添加到最接近的上下文；
  >
  >有变量的声明提升
  >
  >声明提升只提升定义不提升值

  

  >`let`：
  >
  >作用域范围只在块级作用域 ( if，while，for 或 单纯的 {} ) 中，**不能二次声明**
  >
  >没有变量的声明提升
  >
  >十分适用于 for 语句的迭代中 
  >
  >特别地：就算 let 定义的变量没有被块级作用域包裹，就将 let 定义写在全局中，其定义的变量也不属于 `window` 对象；

  

  >`const`：
  >
  >与 let 相同，作用于块级作用域，没有变量声明提升
  >
  >此外，必须在声明时就设定好初始值，且**不能二次赋值**
  >
  >但这里说的不能二次赋值是指 const 变量如果是一个基本数据类型，则不能被二次赋值，若 const 变量为一个引用，例如对象，则该对象的键依旧可以被重新赋值
  >
  >若想使对象的值也不可改变的话，可以使用 `const person = Object.freeze({});`

  

  此外 `let` 和 `const` 中存在一个暂时性死区：

  ````js
  var a = 1;
  var b = 2;
  function fun () {
      console.log(a);		// 1
      console.log(b);		// Uncaught ReferenceError: Cannot access 'b' before initialization
      let b = 1;
  }
  fun();
  ````

  这里的 `b `无法获取到函数作用域外的 `b` 的值就是因为，在 `fun` 中 `let b` 的声明导致函数形成了暂时性死区，无法顺着作用域链去全局中搜索变量。

  

- 链表和数组的区别

  数组是一种线性表的数据结构，是一组连续的内存空间，来存储一组数据，数组创建时，计算机会给其分配一块连续的内存空间，并给出内存首地址 `base_address`，每次访问数组获取数据时，计算机就会根据寻址公示计算出内存地址；

  而链表存储于一组零散的内存块，前一个内存空间的next指针指向下一个内存空间。访问链表时，只需获得链表的头节点，即可通过next指针访问整个链表；

  

- {}、new Object()，Object.create({})的区别

  `{} 和 new Object() ` 除了本身创建的对象，都继承了 Object 原型链上`(Object.prototype)` 的属性或者方法，eg：toString()；当创建的对象相同时，可以说 {} 等价于 new Object() 
  `Object.create() `是将创建的对象继承到原型链上，而本身没有继承 `Object.prototype` 的属性和方法。

  

- `new` 做了什么

  1. 系统首先在构造函数的内部创建了一个实例对象

  2. 该函数的 this 指向实例对象

  3. 根据构造器 `constructor` 中的赋值语句给实例对象创建属性

  4. 返回该实例对象

     

- 事件绑定，解绑

- 垃圾回收机制

  >JS 有自动的垃圾收集机制，垃圾收集器会每隔一段事件就执行一次释放操作，找出那些不再继续使用的值，然后是放其占用内存；
  >
  >以Google的V8引擎为例，V8引擎中所有的JS对象都是通过堆来进行内存分配的：
  >
  >- 初始分配：当声明变量并赋值时，V8引擎就会在堆内存中分配给这个变量。
  >- 继续申请：当已申请的内存不足以存储这个变量时，V8引擎就会继续申请内存，直到堆的大小达到了V8引擎的内存上限为止。
  >
  >V8引擎对堆内存中的JS对象进行分代管理：
  >
  >- 新生代：存活周期较短的JS对象，如临时变量、字符串等。
  >- 老生代：经过多次垃圾回收仍然存活，存活周期较长的对象，如主控制器、服务器对象等。

  局部变量和全局变量的销毁：

  - 局部变量：局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。
  - 全局变量：全局变量什么时候需要自动释放内存空间则很难判断，所以在开发中尽量**避免**使用全局变量。

  >垃圾回收算法的核心思想就是如何判断内存已经不再使用；
  >
  >常用的垃圾回收算法有两种：

  >**引用计数** (被现代浏览器弃用)：引用计数算法定义“内存不再使用”的标准很简单，就是看一个对象是否有指向它的**引用**。如果没有其他对象指向它了，说明该对象已经不再需要了；
  >
  >````js
  >// 创建一个对象person，他有两个指向属性age和name的引用
  >var person = {
  >    age: 12,
  >    name: 'aaaa'
  >};
  >
  >person.name = null; // 虽然name设置为null，但因为person对象还有指向name的引用，因此name不会回收
  >
  >var p = person; 
  >person = 1;         //原来的person对象被赋值为1，但因为有新引用p指向原person对象，因此它不会被回收
  >
  >p = null;           //原person对象已经没有引用，很快会被回收
  >````
  >
  >引用计数有一个致命的问题，那就是**循环引用** ？？？？
  >
  >如果两个对象相互引用，尽管他们已不再使用，但是垃圾回收器不会进行回收，最终可能会导致内存泄露。
  >
  >```js
  >function cycle() {
  >    var o1 = {};
  >    var o2 = {};
  >    o1.a = o2;
  >    o2.a = o1; 
  >
  >    return "cycle reference!"
  >}
  >
  >cycle();
  >```
  >
  >`cycle`函数执行完成之后，对象`o1`和`o2`实际上已经不再需要了，但根据引用计数的原则，他们之间的相互引用依然存在，因此这部分内存不会被回收。所以现代浏览器**不再使用**这个算法。
  >
  >但是IE依旧使用。
  >
  >```js
  >var div = document.createElement("div");
  >div.onclick = function() {
  >    console.log("click");
  >};
  >```
  >
  >上面的写法很常见，但是上面的例子就是一个循环引用。
  >
  >变量div有事件处理函数的引用，同时事件处理函数也有div的引用，因为div变量可在函数内被访问，所以循环引用就出现了

  >**标记清除** (常用)：标记清除算法将 “不再使用的对象” 定义为 “无法到达的对象”。即从根部（在JS中就是全局对象）出发定时扫描内存中的对象，凡是能从根部到达的对象，**保留**。那些从根部出发无法触及到的对象被标记为**不再使用**，稍后进行回收
  >
  >无法触及的对象包含了没有引用的对象这个概念，但反之未必成立。所以上面的例子就可以正确被垃圾回收处理了。
  >
  >所以现在对于主流浏览器来说，只需要切断需要回收的对象与根部的联系。最常见的内存泄露一般都与DOM元素绑定有关：
  >
  >```js
  >email.message = document.createElement(“div”);
  >displayList.appendChild(email.message);
  >
  >// 稍后从displayList中清除DOM元素
  >displayList.removeAllChildren();
  >```
  >
  >上面代码中，`div`元素已经从DOM树中清除，但是该`div`元素还绑定在email对象中，所以如果email对象存在，那么该`div`元素就会一直保存在内存中；

  

  内存泄漏：

  > 对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。 对于不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）

  

- JS数据类型：

- 数组扁平化：

  ````js
  // 方法一：直接使用数组方法 flat()
  arr.flat();
  
  // 方法二：toString()
  // 注意：该方法需要调用map()方法将各项转化为数字，否则各项都为字符串
  arr.toString().split(',').map(Number);
  
  // 方法三：重写flat()方法
  function flatten(arr) {
      // arr.some()，若数组中有任何一项满足条件则返回true
      // 则arr中只要有数组就会再循环中不停的层层解构
      while (arr.some(item => Array.isArray(item))) {
          arr = [].concat(...arr);
      }
      return arr;
  }
  
  // 去重
  [...new Set(arr)]
  ````

  特别地，数组中若有**空项**，在 方法1 中会被自动删去，在 方法2 中会被转化为0，在方法3 中 依旧保持为空；





- 隐式类型转换：

  - 如果参与数学运算的某操作数不是数字类型，那么JavaScript会自动将此操作数转换为数字类型；

    ````js
    3 * '4'			// 12
    true + true		// 2
    false + 2		// 2
    3 * '2天'	   // NaN
    3 + null		// 3
    3 + undefined	// NaN
    ````

    其本质是内部调用 Number() 函数；

    **注意**：若 `+` 的任意一边有字符串参加运算的话，会自动调用 `string()` 采用字符串拼接；

    ````js
    {} + []		// 0
    [] + {}		// [object Object]
    ````

    在第一个算式中 `{}` 会被当成 **代码块**，因此解析的是 `+ []`，而此时 `[].valueof = [] `，不是基本数据类型，因此调用其 `toString()` 方法，将其转换为 `''` 空字符串；

    在第二个算式中 `[]` 同上步骤转化为 `''` 空串，使得后置的 `{}` 隐式类型转换为 `[objext Object]` ，因此结果为 `[object Object]`

  - 对象的属性名：

    ````js
    const obj = {
        a: {},
        b: {a: 2}
    }
    obj[obj.a] = 2;
    obj[obj.b] = 3;
    console.log(obj[{}]);  // 2
    ````

    因为在对象中只有字符串才是标准的属性名，其实此时存储 `2` 的变量名会被为隐式类型转换为字符串 `[object Object]`，因此想要读取 `2`，只需要输入 `obj[{}]` 任意一个对象作为属性名，系统将自动将对象名转化为 `[object Object]` 并访问到变量 `2`;

    

  - 对象到字符串的转换 (这里说的是String()方法的原理)

    1. 若具有 `toString()` 方法，调用 `toString()`，如果它返回一个原始值，将这个原始值转换为字符串返回；
    2. 若无 `toString()` 方法，或 `toString()` 的返回值并不是一个原始值，寻找其`valueOf()` 方法，若存在这个方法，调用它，如果它返回一个原始值，将这个原始值转换为字符串返回；
    3. 否则 (无 `valueOf()` 或 `valueOf()` 的返回值不是原始值），JS无法从`toString()` 或 `valueOf()` 方法获得一个原始值，因此 `throw TypeError`；

  - 对象到数字的转换 (这里说的是Number()方法的原理)

    1. 若具有 `valueOf()` 方法，调用 `valueOf()`，如果它返回一个原始值，将这个原始值转换为数字返回；

    2. 若无 `valueOf()` 方法，或 `valueOf()` 的返回值并不是一个原始值，寻找其`toString()` 方法，若存在这个方法，调用它，如果它返回一个原始值，将这个原始值转换为数字返回；

    3. 否则 (无toString()或toString()的返回值不是原始值)，JS无法从 `toString()` 或`valueOf()` 方法获得一个原始值，因此 `throw TypeError`；

       

  - 调用 `ValueOf()` 也会进行类型转换：

    步骤如下：

    1. 调用ToObject方法得到一个对象O；
    2. 原始数据类型转换为对应的内置对象， 引用类型则不变；
    3. 调用该对象(O)内置valueOf方法；

    ````js
     // 规则如下：
     var str = new String('123')
     console.log(str.valueOf())  // 123
     var num = new Number(123)
     console.log(num.valueOf())  // 122
     var date = new Date()
     console.log(date.valueOf()) // 数字值
     var bool = new Boolean('1')
     console.log(bool.valueOf()) // true, 若为空串则返回false
     var obj = new Object({
         a: 10,
         valueOf: () => {
             return 1
         }
     })
     // 依赖于内部实现，若未实现就该对象
     console.log(obj.valueOf())  // 1
    ````

    ````js
    // 下题隐式类型转换输出：
    var obj1 = {
        valueOf:function(){
            return 1
        }
    }
    var obj2 = {
        toString:function(){
            return 'a'
        }
    }
    //2
    console.log(1+obj1)
    //1a
    console.log('1'+ obj2)
    //1a
    console.log(obj1+obj2)
    ````

    

  - 在 `==` 之间的比较：
    1. 若 x，y 均为 number 类型，直接比较；
    
    2. 若存在对象，且对象有 `valueOf` 属性，返回值与另一个值相等，则相等，否则不等；
    
    3. 存在 boolean，则 `true = 1` or `false = 0`，再进行比较；
    
    4. 若为 string，先转换为 number，再进行比较；
    
    5. 此外 `null = 0` or `undefined = NaN`；
    
       

- `call()` 和 `apply()`

  `Array.prototype.push.apply(arr1, arr2)`：将 `arr2` 合并进 `arr1`，但由于函数可接受参数长度有限，为了避免丢参，在数组长度过多时不宜使用该方法；



- JS 模块化

  >将一个系统分为独立功能部分，严格定义模块接口，更加方便其复用；
  >
  >优点：
  >
  >- 灵活架构，jia

- ES6 的新特性

  1. let/const
  
  2. 模板字符串
  
  3. 解构赋值
  
  4. 剩余参数和展开运算符
  
  5. 对象字面量增强
  
  6. 箭头函数
  
  7. 字符串，数组，对象新增方法
  
  8. Map 和 Set
  
  9. class 类
  
  10. Promise
  
       
  
- 数组去重

- 手写 `bind()`

  ````js
  function bind(fn, obj) {
      return function() {
          return fn.apply(obj, arguments);
      }
  }
  ````

  `bind()` 不同于 `apply` 和 `apply` 只是单纯的设置 `this` 值后传参，且返回绑定 `this` 函数的返回值，`bind()` 还会将所有传入 `bind()` 方法中的实参 (除第一个 `this` 指向外的参数) 与 `this` 一起绑定，例如：

  ````js
  var sum = function(x,y) { return x + y }; 
  var succ = sum.bind(null, 1); //让this指向null，其后的实参也会作为实参传入被绑定的函数sum
  succ(2); // => 3: 可以看到1绑定到了sum函数中的x
  ````

  已知函数有两个属性：`name: 函数名，length: 参数长度`，此时 `bind()` 所返回函数的 `length` 属性等于原函数中的 `length` 属性 减去 已经传入 `bind()` 中的实参个数，上述例子的 `succ,length = 1`；

  **特别地**：当 `bind()` 所返回的函数用作构造函数的时候，`bind()` 的 `this` 将被忽略，实参依旧会传入原函数；

  

  

  

- 手写 `IntanceOf`

- 手写发布订阅模式

- 手写 `Promise` 实现失败后重新请求

- ES7 新特性



### JS性能优化

- JS 单线程

  > 浏览器是多线程的，它们在内核制控下相互配合以保持同步。一个浏览器至少实现三个常驻线程：JavaScript引擎线程，GUI渲染线程，浏览器事件触发线程（UI线程）。

  - javascript引擎是基于事件驱动单线程执行的。JS引擎一直等待着event loop中任务的到来，然后加以处理（只有当前函数执行栈执行完毕，才会去任务队列中取任务执行）。**浏览器无论什么时候都只有一个JS线程在运行JS程序**。
  - UI渲染线程负责渲染浏览器界面，当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时,该线程就会执行。但是 **GUI渲染线程与JS引擎是互斥的**，当JS引擎执行时GUI线程会被挂起，JS对页面的操作即GUI的更新也会被保存在一个队列中，等到JS引擎空闲时才有机会被执行。这就是**JS阻塞页面加载**。
  - 事件触发线程，当一个事件被触发时该线程会把事件添加到任务队列的队尾，等待JS引擎的处理。这些事件可以来自JavaScript引擎当前执行的代码块调用setTimeout/ajax添加一个任务,也可以来自浏览器其他线程如鼠标点击添加的任务。但由于JS的单线程关系，所有这些事件都得排队等待JS引擎处理。

  **注意：**javascript要等主线程空了才会去查看子线程有没有回调内容。异步的任务执行的顺序是不固定的，主要看返回的速度；

  

- DOM的重绘和重排：

  > 重排：若渲染树的一部分更新且尺寸变化，就会发生重排；
  >
  > 重绘：部分节点需要更新，但不改变其他集合形状，如改变某个元素的颜色，就会发生重绘；
  >
  > 回流：浏览器流式布局，DOM节点树形结构，一个节点改变，整个DOM重新计算，引发回流；

  回流触发条件：

  - 首次渲染；
  - 改变DOM节点；
  - DOM节点 `style` 样式的改变，元素位置，元素大小；
  - 页面大小改变，`resize()` 事件；
  - 激活一些伪类；

  **注意**：回流一定重绘，但重绘不一定回流；

  为了提高效率减少重绘，可以进行以下操作：

  - DOM操作不放在循环中；

  - `style` 样式写做 `class`，改变 `class` 即可，只重绘一次；

  - 动画 HTML 的 `position` 尽量设成 `fixed` or `absolute`；

  - 不使用 `table`；

    

- 谈一下对防抖节流的理解

  > 概括来说就是当某事件被触发频率过高，若出路不当或放任不管，很容易引起浏览器卡死；
  >
  > 例如，简体浏览器滚动事件，返回当前滚条与顶部的距离，在运行的时候会发现，该事件被触发的频率太高了，可能随意的一次滑动鼠标滚轮就可以执行 8- 9 次，而实际上，我们并不需要如此高频的反馈，这样会浪费浏览器的性能，为了优化这种场景，就有了防抖节流；

  防抖：

  > 思路：在第一次触发时间时，并不立即执行函数，而是给出一个期限值 (假设为 200ms):
  >
  > - 若 200ms 内没有再次触发滚动事件，就执行函数；
  > - 若 200ms 内再次触发，则当前计时取消，重新开始计时；

  此时效果为若短时间内大量触发同一事件，但依旧只会执行一次函数；

  ````js
  // fn: 需要防抖的函数
  // delay: 防抖期限值
  function debounce(fn, delay) {
      let timer = null;
      return function() {
          // 若该计时器已存在，则清除前一个，重启计时器，则计时也重置
          if (timer) {
          	clearTimeout(timer);   
          }
          timer = setTimeout(fn, delay);
      }
  }
  
  // 调用
  function showTop  () {
      var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
  　　console.log('滚动条位置：' + scrollTop);
  }
  window.onscroll = debounce(showTop,200);
  ````

  节流：

  >根据防抖可知，若此时用户不断地拖动滚动条，就永远无法触发事件，输出当前离顶部的距离；
  >
  >但此时需求为，即使用户不断地拖动滚动条，也能在某个时间间隔之后给出反馈，就需要用到防抖的知识；
  >
  >思路：设计一个定期开放的控制阀门，在函数执行一次后另阀门在某时间段内暂时失效，过了该时间段再重新激活；

  ````js
  function throttle(fn,delay){
      let valid = true
      return function() {
         if(!valid){
             //休息时间 暂不接客
             return false 
         }
         // 工作时间，执行函数并且在间隔期内把状态位设为无效
          valid = false
          setTimeout(() => {
              fn()
              // 执行完毕后，打开该控制阀门
              valid = true;
          }, delay)
      }
  }
  
  function showTop  () {
      var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
  　　console.log('滚动条位置：' + scrollTop);
  }
  window.onscroll = throttle(showTop,1000);
  ````

  节流函数并不止上面这种实现方案：

  - 也可以把状态位换成时间戳，然后利用时间戳差值是否大于指定间隔时间来做判定；
  
  - 也可以直接将setTimeout的返回的标记当做判断条件-判断当前定时器是否存在，如果存在表示还在冷却，并且在执行fn之后消除定时器表示激活；
  
    

- 前端加载较慢时，需要从哪些方面排查问题
  1. 检查 css，js，图片文件大小，可考虑压缩文件；
  
  2. 检查 css，js，图片文件数量，考虑合并资源，减少网络请求数量；
  
  3. 检查 js 文件位置，考虑将外部资源文件或者不是首屏加载的文件放在最后加载；
  
  4. 检查文档元素操作，避免平凡的重绘或重绘页面 (display: none 的使用)；
  
  5. 可以使用 cdn来缓存资源文件；
  
  6. 检查 cookie 值是否过大，考虑改用 webStorage；
  
  7. 检查后端接口损耗时，考虑将一些接口异步加载；
  
     
  
- 非核心代码异步加载

  - `script` 直接加载：

    > 正常情况下，当浏览器在解析HTML源文件时如果遇到外部的script，那么解析过程会暂停，并发送请求来下载script文件，只有script完全下载并执行后才会继续执行DOM解析。
    >
    > 当一个页面有很多的外链的脚本。放在head中，那么加载脚本的时候就会阻塞页面的渲染，出现空白的现象。
    >
    > 在简单的开发环境中可能调整一下js的位置就能解决问题。但是在越来越复杂的开发环境下，如果想调整js脚本的位置可能就要花费大量的时间。所以为了让这种成本降低。可以使用defer属性。

  - 标签中加 `defer` 关键字：

    >一个script加了defer属性，即使放在head里面，它也会在html页面解析完毕之后再去执行，也就是类似于把这个script放在了页面底部。

  - 标签中加 `async` 关键字：

    >对于async，这个是html5中新增的属性，它的作用是能够异步的加载和执行脚本，不因为加载脚本而阻塞页面的加载。一旦加载到就会立刻执行。

  

  `defer` 和 `async` 的区别：

  - 两者的相同点：
    1. 加载文件时不阻塞页面渲染。
    2. 对于inline的script无效。
    3. 使用这两个属性的脚本中不能调用document.write方法。
    4. 有脚本的onload的事件回调。

  - 不同点：

    1. html4.0中定义了defer，html5.0中定义了async。

    2. async属性的脚本会在下载结束后立刻执行，同时会在window的load事件之前执行，所以就会出现顺序被打乱的情况；

       defer属性的脚本是在页面解析完成后，按照顺序执行，同时会在document的DOMContentLoaded之前执行。

    总体来说，defer和async的主要不同就是defer会保证脚本的顺序，async不保证顺序；

  

### React

- 组件化的理解以及如何去构建一个组件

- `react diff` 算法

  > 计算出 `VDOM` 中真正变化的部分，并只针对该部分对原生 `DOM` 进行操作，而非重新渲染整个页面；
  >
  > 
  >
  > 传统的 `DOM` 算法，是通过循环递归对节点进行依次对比，时间复杂度达到 `O(n^3)`，这样会导致页面更新的十分慢，影响用户体验，因此对 `diff` 算法进行以下三方面的改进：
  >
  > - `tree diff`：
  >
  >   `Web UI` 中 `DOM` 节点**跨层级移动操作较少，可忽略不计**；
  >
  > - `component diff`：
  >
  >   拥有相同类的两个组件，生成相似的树形结构；
  >
  >   拥有不同类的两个组件，生成不同的树形结构；
  >
  > - `element diff`：
  >
  >   对于**同一层级**的一组子节点，通过为一的 `id` 进行区分；
  >
  > 针对以上三方面，`diff` 算法只会对同一层次的节点进行比较，若某节点不存在时，会对该节点及其子节点进行完全删除，不会进行进一步比较，且只需遍历一次就能完成整颗 `DOM` 树的比较，若出现跨层级的操作，只能创建节点和删除节点的操作；

  

- 虚拟DOM的优点

- `React Hooks` 的优缺点

  优点：

  1. 更容易复用代码
  2. 清爽的代码且风格代码量少

  缺点：

  1. 响应式的`useEffect`
  2. 状态不同步

  

- React中的 `setState` 什么时候是同步的,什么时候是异步的

  >在React中，**如果是由React引发的事件处理（比如通过onClick引发的事件处理），调用setState不会同步更新this.state，除此之外的setState调用会同步执行this.state** 。所谓“除此之外”，指的是绕过React通过addEventListener直接添加的事件处理函数，还有通过setTimeout/setInterval产生的异步调用。
  >
  >**原因：** 在React的setState函数实现中，会根据一个变量isBatchingUpdates判断是直接更新this.state还是放到队列中回头再说，而isBatchingUpdates默认是false，也就表示setState会同步更新this.state，但是，**有一个函数batchedUpdates，这个函数会把isBatchingUpdates修改为true，而当React在调用事件处理函数之前就会调用这个batchedUpdates，造成的后果，就是由React控制的事件处理过程setState不会同步更新this.state**。
  >
  >**注意：** setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的callback拿到更新后的结果。

- React 中的单向数据流和双向数据绑定

  > react的单向数据流实际上就是指父组件通过 `props` 传递 `state` 给子组件，而子组件获取父组件状态之后，是只读的，并不能通过任何操作来改变该值在父组件中的值，除非在父组件中定义操作该 `state` 的方法，并且通过 `prop` 一同传递给子组件供子组件调用，这样降低了组件之间的耦合程度，避免在其他组件中修改自身组件的数据而造成的混乱；

  > react的双向数据绑定：
  >
  > 双向数据绑定是指，视图会根据数据模型来进行一个动态显示，放在react中就是指 `state` 数据会驱动页面的显示，最常用的，填写表单中获取的数据，就是一种双向数据绑定，vue中有 `v-modal` 指令实现双向数据绑定，但是react中没有类似指令，所以就通过 onChange 事件监听元素的改变，再通过 `this.setState` 实现更新状态中数据；

- 组件间的几种通信方式

  父传子：`props`；

  子传父：

  - `props`：

    ````jsx
    class Child extends React.Component{
        data =  '我是子组件中的data'
        render(){
            this.props.getChildData(this.data);
            return <div>我是Child组件</div>
        }
    }
    class Parent extends React.Component{
        childData=null
        getChildData = (data)=>{
            this.childData = data;
            console.log(data);
        }
        render(){
            return <Child getChildData = { this.getChildData }  />
        }
    }
    ````

    此时 `Parent` 组件中的 `childData` 为 `我是子组件中的data`，其实这并不违反 react 的单项数据流，这也是将 父组件的属性作为 `props` 传递下去，只是该属性是一个函数，子组件取到该方法后，将数据作为参数传入该方法中，而父组件通过形参接收子组件数据；

  - `refs`：

    > 类似 html 标签中的 id，使用在一般 dom 中，可获取该 dom实例 的数据;
    >
    > 使用在子组件中，可获取子组件实例中的所有数据；
    >
    > 但是该方法需要谨慎使用；

  同级无嵌套关系：

  - 通过第三方媒介方式
    1. 通过缓存：组件A把数据存到缓存中，组件B就可以从中取出;
    2. 通过url：通过location对象拿到…；
    3. 通过与后端配合：组件A把数据扔到接口里去，组件B可以从中拿到…；
    4. redux，react-redux；
  - `context`
  - 发布订阅机制

  

### 计算机网络

- TCP的三次握手和四次挥手

- 输入url之后发生的事情以及浏览器渲染原理(DNS解析 HTTP握手 渲染什么的都仔细问了)

  1. 解析 URL (协议 + 域名 + 数据源文件路径名)；

  2. DNS域名查询，获取 IP 地址；

  3. 根据 IP 地址找到服务器，TCP 三次握手进行连接；

  4. 发送 HTTP 请求，请求页面资源；

  5. 收到 HTTP 响应，获取页面资源；

  6. 浏览器是渲染页面：
     - 解析HTML文件，创建DOM树自上而下，遇到任何 脚本 与 样式都会阻塞 (外部样式不阻塞，后续外部脚本加载)；

     - 解析 CSS 优先级：浏览器默认设置 < 用户设置 < 外部样式 < 内联样式 < HTML中的style 样式；

     - 将 CSS 与 DOM 合并，构建渲染树，DOM树 与 HTML 一 一对应，渲染树会忽略设置了 `display: none` 等样式的元素；

     - 布局和绘制，重绘和重排：

     

- URL里每部分是什么

  

- get和post的区别

  1. get的传参方式是通过地址栏url传参，是直接可视的，post传参是将参数放在body内传输；

  2. get因为通过url传输因此大小受到限制，url最大长度为2048个字符，post则无长度限制；

  3. get请求有幂等性，post请求每次提交新数组，并不是安全且幂等的；

  4. get请求可以被缓存，post请求不可以被缓存；

  5. get请求只支持url编码，post请求支持多种编码方式 (application/x-www-form-urlencoded，multipart/form-data，application/json， text/xml)；

  6. get的请求记录会留在浏览器中，post不会；

  7. get只支持ASCII字符，post没有字符类型限制；

     

- 网络请求的响应状态码：

  ![image-20210715011319577](image-20210715011319577.png)

  

  - **1xx：**属于提示信息，是协议处理中的⼀种中间状态，实际⽤到的⽐较少。

  - **2xx：**表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态。
    - 「200 OK」是最常⻅的成功状态码，表示⼀切正常。如果是⾮ HEAD 请求，服务器返回的响应头都会有 body 数据。
    - 「204 No Content」也是常⻅的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。
    - 「**206 Partial Content**」是应⽤于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，⽽是其中的⼀部分，也是服务器处理成功的状态。

  - **3xx：**表示客户端请求的资源发送了变动，需要客户端⽤新的 URL 新发送请求获取资源，也就是重定向。

    - 「301 Moved Permanently」表示永久᯿定向，说明请求的资源已经不存在了，需改⽤新的 URL 再次访问。
    - 「302 Found」表示临时定向，说明请求的资源还在，但暂时需要⽤另⼀个 URL 来访问。

    301 和 302 都会在响应头⾥使⽤字段 Location ，指明后续要跳转的 URL，浏览器会⾃动᯿定向新的 URL。 

    - 「304 Not Modified」不具有跳转的含义，表示资源未修改，定向已存在的缓冲⽂件，也称缓存定向，⽤于缓存控制。

  - **4xx：**表示客户端发送的报⽂有误，服务器⽆法处理，也就是错误码的含义。
    - 「400 Bad Request」表示客户端请求的报⽂有错误，但只是个笼统的错误。
    - 「403 Forbidden」表示服务器禁⽌访问资源，并不是客户端的请求出错。
    - 「404 Not Found」表示请求的资源在服务器上不存在或未找到，所以⽆法提供给客户端。

  - **5xx：**表示客户端请求报⽂正确，但是服务器处理时内部发⽣了错误，属于服务器端的错误码。

    - 「500 Internal Server Error」与 400 类型，是个笼统通⽤的错误码，服务器发⽣了什么错误，我们并不知道。

    - 「501 Not Implemented」表示客户端请求的功能还不⽀持，类似“即将开业，敬请期待”的意思。

    - 「502 Bad Gateway」通常是服务器作为⽹关或代理时返回的错误码，表示服务器⾃身⼯作正常，访问后端服务器发⽣了错误。

    - 「503 Service Unavailable」表示服务器当前很忙，暂时⽆法响应服务器，类似“⽹络服务正忙，请稍后重试”的意思

      

- 304什么意思？也就是要讲讲http 缓存机制

- HTTP 1.1/ HTTP 2 .... 区别

- http2.0有什么缺点？为什么会有http3.0？

- HTTP的理解

- `cookie` 携带在哪里发送，以及其常见属性

- HTTP 常见请求头

  1. `accept`：浏览器可接受的服务器返回类型

  2. `accept-encoding`：浏览器声明可接受的编码压缩方法(gzip)；

  3. `accept-language`：浏览器声明自己接收的语言；

  4. `connection`：指定是否使用长连接 (keep-alive)；

  5. `referer`：字段，告诉服务器此请求来自哪个页面链接；

  6. `host`：指定被请求资源所在域名；

  7. `cookie`：用来存储用户信息；

  8. `User-Agent`：客户端使用的操作系统版本以及浏览器的名称和版本；

  9. `Cache-Control`：缓存控制

     ![img](20180921155944100)

     

- HTTP 常见响应头

  1. `Cache-Control`：对应请求中的Cache-Control

     ![在这里插入图片描述](2018092116013247)

  2. `Last-Modified`：表示所请求的响应对象最后的修改时间；

  3. `Etag`：类似于一个html文件的摘要，服务器会将请求收到的 `Etag`，与响应的 `Etag` 进行对比，判断文件是否变化，是否可以继续读取缓存中的页面；

  4. `Content-Type`：告诉客户端，资源文件的类型和字符编码类型；

  5. `Content-Encoding`：对应 `Accept-Encoding`，表示编码的压缩方法；

  6. `Date`：服务器发送资源时的时间；

  7. `Expires`：缓存相关响应头，表示缓存保存的最大时间，但该响应头没有 `Cache-Control: max-age` 准确，因为那是相对时间，而该字段只能设置绝对时间；

  8. `Connection`：与请求头中 `Connection` 对应，也回应 `keep-alive`;

  9. `Refresh`：用于重定向，返回重定向时间以及重定向网址；

  10. `Access-Control-Allow-Origin` / `Access-Control-Allow-Methods` / `Access-Control-Allow-Credentials`：允许跨域的三个响应头；

      

- 什么是跨域，如何请求跨域资源？

  由于浏览器的同源策略，凡是发送请求 url 的协议，域名，端口三者之间任一与当前页面地址不同即为跨域：

  1. 网络协议不同：http 和 https；
  2. 端口不同：3000 访问 5000；
  3. 域名不同：www.youzan.com 访问 open.weixin.com；
  4. 子域名不同：zhifuyun.youzan.com 访问 store.youzan,com；

  实现跨域的方法：

  - `proxy` 代理：将请求发送给中间的代理服务器，由代理服务器去转发请求 (因为服务器不存在跨域情况)，请求到的结果也会先发给代理服务器，再由代理服务器提供给当前页面；

    在生产环境中，常使用在 `package.lock.json` 中配置  `proxy`(配置单个代理) 或 `src` 下创建 `setupProxy` (配置多个代理)；
    
    在打包环境中，常用 `nginx`;
    
  - CORS：在后台处理请求时，增加允许跨服的语句；
  
    `Access-Control-Allow-Origin`
  
    `Access-Control-Allow-Methods`
  
    `Access-Control-Allow-Header`
  
  - `jsonp`：利用了 `script` 标签的 `src` 不受浏览器同源策略的影响，允许跨域引用资源的性质进行跨域，当前较为流行，但只支持Get请求；
  
    ````js
    // 1. 定义一个 回调函数 handleResponse 用来接收返回的数据
    function handleResponse(data) {
        console.log(data);
    };
    
    // 2. 动态创建一个 script 标签，并且告诉后端回调函数名叫 handleResponse
    var body = document.getElementsByTagName('body')[0];
    var script = document.gerElement('script');
    script.src = 'http://www.laixiangran.cn/json?callback=handleResponse';
    body.appendChild(script);
    
    // 3. 通过 script.src 请求 `http://www.laixiangran.cn/json?callback=handleResponse`，
    // 4. 后端能够识别这样的 URL 格式并处理该请求，然后返回 handleResponse({"name": "laixiangran"}) 给浏览器
    // 5. 浏览器在接收到 handleResponse({"name": "laixiangran"}) 之后立即执行 ，也就是执行 handleResponse 方法，获得后端返回的数据，这样就完成一次跨域请求了。
  
  - `document.domain`：解决主域名相同，但子域名不同的情况，适用于 iframe 跨域；
  
    对于主域名相同，而子域名不同的情况，可以使用 document.domain 来跨域。这种方式非常适用于 iframe 跨域的情况。
  
    比如，从地址是 `http://www.laixiangran.cn/a.html`，访问 src 为 `http://laixiangran.cn/b.html` 的 iframe。此时子域不同，无法通过在页面中书写 js 代码来获取 iframe 中的内容。
  
    为了解决只需要将两个页面的 `document.domain` 设成相同的域名即可：
  
    ````html
    // a.html
    <iframe src="http://laixiangran.cn/b.html" id="myIframe" onload="test()">
    <script>
        document.domain = 'laixiangran.cn'; // 设置成主域
        function test() {
            console.log(document.getElementById('myIframe').contentWindow);
        }
    </script>
    
    // b.html
    <script>
        document.domain = 'laixiangran.cn'; // document.domain 设置成与主页面相同
    </script>
    ````
  
    **注意**：document.domain 的设置是有限制的，我们只能把 document.domain 设置成自身或更高一级的父域，且主域必须相同。例如：`a.b.laixiangran.cn` 中某个文档的 document.domain 可以设成 `a.b.laixiangran.cn`、`b.laixiangran.cn` 、`laixiangran.cn` 中的任意一个，但是不可以设成 `c.a.b.laixiangran.cn` ，因为这是当前域的子域，也不可以设成 `baidu.com`，因为主域已经不相同了。
    
    
  
- `socket` 和 `webSocket`

  > 在网络中的**两个进程**需要全双工相互通信 (双方可同时向对方发送消息)，需要用到`socket`，它能够提供**端对端通信**。
  >
  > 程序员只需要在某个应用程序的一端 (eg: 客户端) 创建一个 `socket`,mkn 实例并且提供它所要连接一端 (eg: 服务端) 的IP地址和端口，而另外一端创建另一个 `socket` 并绑定本地端口进行 `listen`，然后客户端进行 `connect` 服务端，服务端接受连接之后双方建立了一个端对端的TCP连接，在该连接上就可以双向通讯了；
  >
  > 一旦建立这个连接之后，通信双方就没有客户端服务端之分了，提供的就是端对端通信了。
  >
  > 从本质上来说，socket并不是一个新的协议，它只是为了便于程序员进行网络编程而对tcp/ip协议族通信机制的一种封装。

  >`websocket` 是 `html5` 规范中的一个部分，它借鉴了 `socket` 思想，为web应用程序**客户端和服务端**之间提供了一种全双工通信机制；
  >
  >同时，它又是一种新的应用层协议，通常表示为：`ws://echo.websocket.org/?encoding=text HTTP/1.1`，除了协议名和http不同之外，它的表示地址就是传统的url地址；
  >
  >
  >
  >websocket具有以下几个方面的优势：
  >
  >1. 建立在 TCP 协议之上，服务器端的实现比较容易；
  >2. 与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器；
  >3. 数据格式比较轻量，性能开销小，通信高效；
  >4. 可以发送文本，也可以发送二进制数据；
  >5. 没有同源限制，客户端可以与任意服务器通信；
  >6. 协议标识符是`ws`（如果加密，则为`wss`），服务器网址就是 URL；
  >
  >
  >
  >webSocket 与 HTTP/2服务器主动推送 的区别：
  >
  >**HTTP/2 引入了 Server Push ，它使服务器能够主动地将资源推送到客户端缓存。但是，它并不允许将数据推送到客户端应用程序本身**。服务器推送只能由浏览器处理，不会在应用程序代码中弹出服务器数据，这意味着应用程序没有 API 来获取这些事件的通知；
  >
  >而 webSocket 是全双工通信，将数据推送到客户端本身；

  

- TCP 和 UDP的区别

  1. TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接
  2. TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付；
  3. TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道；
  4. TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的，UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）
  5. 每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信；
  6. TCP首部开销20字节，UDP的首部开销小，只有8个字节；

   

- 前端安全问题：

  1. XSS (跨站脚本攻击)：

     > html 或 js 脚本攻击，恶意攻击者向 `Web` 页面中插入恶意代码 (一般会在 a 标签或者 img 标签前插入一些 html 或 js 脚本)，当用户浏览网页时，这些恶意代码会被执行从而达到恶意攻击用户的目的；
     >
     > 通常是通过 php 输出函数将 js 代码输出到 html 页面中，通过用户本地浏览器执行；
     >
     > 
     >
     > 预防 XSS 攻击：
     >
     > 1、前端替换关键字，如替换`<`为`<` `>` 为`>`
     > 2、后台替换。
     > 3、任何内容写到页面之前都必须加以encode，避免不小心把html tag 弄出来。

  2. CSRF (跨站请求伪造)：
  
     > CSRF也称为跨站请求伪造，其实就是对网站中的一些表单提交行为被黑客利用。例如在登陆 A 网站时存在 cookie 中的一些个人信息，而在退出登录之前，无意点击访问黑客的网站时，黑客网站收到用户的页面请求后，返回一些攻击性代码，并发出请求 (提交url) 求用户访问 A 网站，浏览器在接收到攻击性代码后，就根据黑客网站的请求，在用户不知情的情况下，携带用户的 cookie 信息，向 A 网站发出请求；而 A 网站并不知道请求是由黑客网站发起的，因此会根据恶意请求进行操作；
     >
     > 
     >
     > 预防 CSRF 攻击：
     >
     > - 验证 HTTP Referer：
     >
     >   在 HTTP 头部中有 Referer 字段，记录了 HTTP 请求的来源地址，但若黑客要对网站进行攻击，只能在自己的网站构造请求，因此当 A网站发现 Referer 不是规定网站的话，就会拒绝该请求；
     >
     > - 在请求地址中添加 token 并验证：
     >
     >   CSRF 攻击在于黑客网站能完全伪造请求，在传统的 Session 请求中的所有用户验证信息，都是存在 cookie 中，因此黑客可以在不知道验证信息的情况下直接利用用户自己的 cookie 通过安全验证；因此可以在请求中放入黑客不能伪造的信息，且该信息不存在于 cookie 中；
     >
     >   此时就可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务端建立拦截器来验证该 token，如果请求中没有 token 或者内容不正确，则拒绝请求；
     >
     > - 在 HTTP 投中自定义属性并进行验证：
     >
     >   同样是使用 token 进行验证，但是把 token 放在 HTTP 请求头的自定义属性中；

  3. 本地存储数据问题：一些个人信息不经加密就存储在本地或cookie中是极度不安全的，这会导致信息十分容易被盗用；

  4. HTTPS加密传输数据：

     >在浏览器对服务器访问或者请求的过程中，会经过很多的协议或者步骤，当其中某一步被拦截时，若没有被加密就极易被盗取；
     >
     >HTTPS中间人攻击：
     >
     >1. 服务器向客户端发送公钥，攻击者截获公钥，保留在自己手上，然后攻击者自己生成一个【伪造的】公钥，发给客户端。
     >2. 客户端收到伪造的公钥后，生成加密hash值发给服务器，攻击者获得加密hash值，用自己的私钥解密获得真秘钥，同时生成假的加密hash值，发给服务器；
     >3. 服务器用私钥解密获得假秘钥，服务器假秘钥加密传输信息；
     >
     >此时如果使用了数字证书，将服务器的公钥放入数字证书中再发送给客户端。则浏览器可以通过自身内置的CA的公钥验证数字证书的真实性；

  5. SQL注入

     >通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令
     >
     >
     >
     >预防 SQL 注入的方法：
     >
     >- 永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双"-"进行转换等。
     >- 永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询存取。
     >- 永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
     >- 不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。

     

  - CSRF 与 XSS区别：
    - XSS是向页面注入js去运行，然后在js函数体中做他想做的事情。
      CSRF是利用网站漏洞，自动执行接口。用户需要登陆网站。
    - XSS是获取信息，不需要提前知道其他用户页面的代码和数据包。
      CSRF是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。

### webpack

- webpack配置流程

- webpack怎么加载CSS，加载器做了什么

  

### AJAX

- Ajax原理：

  1. 创建对象：`var xhr = new XMLHttpRequest()`

  2. 创建请求：`xhr.open('GET', 'example.txt', true)`

  3. 发送请求:：`xhr.send()`

  4. 接收响应：`xhr.onreadystatechange = function(){}`

     - 当 `readystate` 的值改变时就会触发该事件；

     - 若 `readystate == 4`，表示已经接收到所有的响应数据；

     - 当 `status == 200`时，表示服务器已成功返回页面和数据；

     - 若该事件被触发且以上两点全部满足，则可以通过 `xhr.responseText`，获得服务器返回内容；

       

- axios拦截器的原理?

- axios怎么区分[客户端](https://www.nowcoder.com/jump/super-jump/word?word=客户端)和服务器端的请求?

- `cookie`、`sessionstorage` 、`localstorage`

  1. 后两者是新特性，同样保存在浏览器端；
  2. `localstorage` 生命周期是永久的，除非调用 api 清除，且其不参与和服务器的通信，数据大小 5M 左右；
  3. `sessionStorage` 仅在当此会话有效，浏览器关闭即被清除，不参与与服务器通信，数据大小 5M 左右；
  4. `cookie` 储存大小 4k 左右，一般不超过 20 个，在有效期前一直有效，参与与服务器通信，会被携带在请求头中；

- cookie有哪些属性？samesite了解嘛？

- cookie跨域吗？那cookie跨域要怎么做？

- readyState 属性表示Ajax请求的当前状态。它的值用数字代表。

  > 0 代表未初始化。 还没有调用 open 方法
  > 1 代表正在加载。 open 方法已被调用，但 send 方法还没有被调用
  > 2 代表已加载完毕。send 已被调用。请求已经开始
  > 3 代表交互中。服务器正在发送响应
  > 4 代表完成。响应发送完毕

- 讲讲同源策略cors

  > 同源策略是一种约定，Web是构建在同源策略的基础之上的，浏览器只是针对同源策略的一种实现；其核心在于它认为自任何站点装载的信赖内容是不安全的。当被浏览器半信半疑的脚本运行在沙箱时，它们应该只被允许访问来自同一站点的资源，而不是那些来自其它站点可能怀有恶意的资源。

  同源策略又分为以下两种：

  - **DOM 同源策略**：禁止对不同源页面 DOM 进行操作。这里主要场景是 iframe 跨域的情况，不同域名的 iframe 是限制互相访问的。

    如果没有 DOM 同源策略，也就是说不同域的 iframe 之间可以相互访问，那么黑客可以这样进行攻击

    1. 做一个假网站，里面用 iframe 嵌套一个银行网站 `http://mybank.com`；
    2. 把 iframe 宽高啥的调整到页面全部，这样用户进来除了域名，别的部分和银行的网站没有任何差别；
    3. 这时如果用户输入账号密码，我们的主网站可以跨域访问到 `http://mybank.com` 的 dom 节点，就可以拿到用户的账户密码了；

  - **XMLHttpRequest 同源策略**：禁止使用 XHR 对象向不同源的服务器地址发起 HTTP 请求。

    如果没有 XMLHttpRequest 同源策略，那么黑客可以进行 CSRF（跨站请求伪造） 攻击：

    1. 用户登录了自己的银行页面 `http://mybank.com`，`http://mybank.com` 向用户的 cookie 中添加用户标识。
    2. 用户浏览了恶意页面 `http://evil.com`，执行了页面中的恶意 AJAX 请求代码。
    3. `http://evil.com` 向 `http://mybank.com` 发起 AJAX HTTP 请求，请求会默认把 `http://mybank.com` 对应 cookie 也同时发送过去。
    4. 银行页面从发送的 cookie 中提取用户标识，验证用户无误，response 中返回请求数据。此时数据就泄露了。
    5. 而且由于 Ajax 在后台执行，用户无法感知这一过程。

### Node.js

- Common.js 的 require 和 ES6 的 module有什么区别

  >曾经的js没有模块体系无法拆分为多个模块文件，因此出现了统一的规范(Common.js和AMD)，前者是争对服务端(Node.js)，后者是针对浏览器；ES6在语言标准层面上，实现了模块功能；
  >
  >Node.js主流还是采用Common.js规范，但是在v13.2版本已经实现了ES6模块语法，但未正式替换，v13.2版本将`js`文件以 `.mjs`结尾则将其视为`ES6`模块。以 `.cjs` 结尾则视为 `Common.js` 模块。也可以在包的package.json文件中增加 "type": "module"信息。nodejs则将整个包都视为ES6模块来加载运行
  
- 事件循环打印：

  ````js
  for(var i=0;i<5;i++) {
      setTimeout(()=>{
          console.log(i)
      }, i*1000)
  }
  // 打印什么
  
  let promise = new Promise((res,rej)=>{
       setTimeout(()=>{
          console.log(0)
      },0)
      console.log(1)
      res();
      rej();
  })
  promise.then(()=>{
      console.log(2)
    },()=>{
         console.log(3)
     } 
  )
  js闭包
  function fun(){
      let a =1
      function fun1(){
          console.log(a);
      }
      fun1();
  }
   
  fun();
  // 打印什么
  ````

  

- 事件循环

  >JS引擎常驻于内存中，等待宿主将JS代码或者函数传递给它，也就是等待宿主环境分配宏观任务，反复等待 - 执行 即为事件循环；
  >
  >
  >
  >执行栈：是一个存储函数调用的栈结构，遵循先进后出的原则，在开始执行 js 代码之前，会执行一个 `main` 函数，然后执行代码；更具先进后出的原则，后执行的函数会先弹出栈

  ![img](25750-50b8dfd7f560fe04.webp)

  >Event Loop中，每一次循环称为tick，每一次tick的任务如下：
  >
  >- 执行栈选择最先进入队列的宏任务（一般都是script），执行其同步代码直至结束；
  >- 检查是否存在微任务，有则会执行至微任务队列为空；
  >- 如果宿主为浏览器，可能会渲染页面；
  >- 开始下一轮tick，执行宏任务中的异步代码（setTimeout等回调）。

  ![2100352608-7bccadc45cd17413](2100352608-7bccadc45cd17413-1626947390046.gif)

  >执行步骤：
  >
  >1. 执行函数 `a()`先入栈
  >2. `a()`中先执行函数 `b()` 函数`b()` 入栈
  >3. 执行函数`b()`, `console.log('b')` 入栈
  >4. 输出 `b`， `console.log('b')`出栈
  >5. 函数`b()` 执行完成，出栈
  >6. `console.log('a')` 入栈，执行，输出 `a`, 出栈
  >7. 函数a 执行y，出栈。

  事件队列：

  在任务的执行过程中，遇到异步事件，并不会等待他的返回结果，而是将事件挂起，继续执行执行栈中的其他任务；当异步事件返回结果，再将它放到事件队列中，但并不会立即执行，而是等待当前执行栈中的任务都执行完毕，主线程空闲状态，主线程会去查找事件队列中是否有任务，如果有则取出排在第一位的时间，并把该事件的回调放到对应的执行栈中，然后继续执行其中的同步代码；

  

- 宏任务和微任务：

  >ES6 规范中，microtask 称为 `jobs`，macrotask 称为 `task`
  >宏任务是由宿主发起的，而微任务由JavaScript自身发起。
  >
  >页面渲染事件 和 各种IO完成事件等随时会被添加到任务队列中，队列会一致保持先进先出的原则执行，我们并不能准确的控制这些事件被添加到任务队列中的位置。此时若突然由高优先级的任务需要尽快执行，那么一种类型的任务就没办法满足了，因此引入了微任务队列；

  所以，总结一下，两者区别为：

  ![image-20210722164321588](image-20210722164321588.png)

  >**运行机制**：
  >
  >异步任务的返回结果会被放到一个任务队列中，根据异步事件的类型，这个事件实际上会被放到对应的宏任务和微任务队列中去。
  >
  >在当前执行栈为空时，主线程会查看微任务队列是否有事件存在
  >
  >- 存在，依次执行队列中的事件对应的回调，直到微任务队列为空，然后去宏任务队列中取出最前面的事件，把当前的回调加到当前指向栈。
  >- 如果不存在，那么再去宏任务队列中取出一个事件并把对应的回到加入当前执行栈；
  >
  >当前执行栈执行完毕后时会立刻处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行。
  >
  >
  >
  >在事件循环中，每进行一次循环操作称为 tick，每一次 tick 的任务处理模型是比较复杂的，但**关键步骤**如下：
  >
  >- 执行一个宏任务（栈中没有就从事件队列中获取）
  >- 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中
  >- 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）
  >- 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染
  >- 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）

  ````js
  console.log('start')
  
  setTimeout(function() {
    console.log('setTimeout')
  }, 0)
  
  Promise.resolve().then(function() {
    console.log('promise1')
  }).then(function() {
    console.log('promise2')78I
  })
  
  console.log('end')
  ````

  ![1653721873-5adb68e2247cf](1653721873-5adb68e2247cf.gif)

  ````js
  const p = function() {
      return new Promise((resolve, reject) => {
          const p1 = new Promise((resolve, reject) => {
              setTimeout(() => {
                  resolve(1)
              }, 0)
              resolve(2)
          })
          p1.then((res) => {
              console.log(res);
          })
          console.log(3);
          resolve(4);
      })
  }
  
  
  p().then((res) => {
      console.log(res);
  })
  console.log('end');
  
  /*
  最后的执行结果如下:
  3
  end
  2
  4
  */
  ````
  
  ````js
  new Promise(resolve => {
      console.log(1);
      setTimeout(() => {
          console.log(5);
      }, 0);
      resolve(3);
      Promise.resolve().then(() => console.log(4));
  }).then(num => {
      console.log(num);
  })
  console.log(2);
  /*
  最后的执行结果如下:
  1
  2
  4
  3
  5
  */
  ````
  
  注意：虽然 `resolve(3)` 书写在 `Promise.resolve().then(() => console.log(4))` 之前，但是他是一个回调函数，会在自身的 `Promise` 执行结束之后再去执行自身 `.then()` 的内容，因此要先输出 4 再 输出 3；
  
  
  
  >Node 事件循环阶段如下：
  >
  >- 定时器检测阶段(timers): 这个阶段执行定时器队列中的回调如 setTimeout() 和 setInterval()。
  >- I/O事件回调阶段(I/O callbacks): 这个阶段执行几乎所有的回调。但是不包括close事件，定时器和setImmediate()的回调。
  >- 闲置阶段(idle, prepare): 这个阶段仅在内部使用，可以不必理会
  >- 轮询阶段(poll): 等待新的I/O事件，node在一些特殊情况下会阻塞在这里。
  >- 检查阶段(check): setImmediate()的回调会在这个阶段执行。
  >- 关闭事件回调阶段(close callbacks): 例如socket.on('close', ...)这种close事件的回调
  >
  >
  >
  >Node中事件循环的顺序：
  >
  >外部输入数据 --> 轮询阶段（poll） --> 检查阶段(check) --> 关闭事件回调阶段(close callback) --> 定时器检查阶段(timer) --> I/O 事件回调阶段(I/O callbacks) --> 闲置阶段(idle, prepare) --> 轮询阶段...



### 计算机基础

- 常见的几种编码方式

  1. `ASCII` 码

     > 最初只需要表示一些英文字符、阿拉伯数字、西文字符以及32个控制字符，则一个字节表示具体字符，规定只用其后期为来表示字符 (2^7 = 128)，最前的一位统一规定为 0；
     >
     > 后来因为欧洲国家，含有拼音，128位不足以表示现有字符，则将最高位的 0 也用来表示字符，变为 (2^8 = 256)，表示 扩展`ASCII`码；
     >
     > 但因为不同国家的字母不同，因此产生使用同一种编码方式，代表字母却不一样的情况，因此产生了 `Unicode`;

  2. `Unicode` 字符集

     > 包含世界上所有符号，并且每个符号都有独一无二的编号，其本质为一个符号集 (类似字典)，并不是一种新的编码方式；
     >
     > 但在 `Unicode` 中，有些字符用一个字节即可表示，有些字符则需要使用两个字节，则产生两个问题：
     >
     > 1）若有两个字节的数据，并不知道其是用来保存一个汉字，还是两个英文字符；
     >
     > 2）若规定 `Unicode` 统一用两个字节来存储，那么对于只占一个字节的字符，就极大的浪费了空间；
     >
     > 因此急需一种风格统一的编码方式来实现 `Unicode`，于是产生了 `UTF-8`；

  3. `UTF-8`

     > **`Unicode` 的一种最为常见的实现方式**；
     >
     > 可以使用 `1-4` 个字节表示一个符号，更具不同符号而变化字节的长度；
     >
     > 其规则为：
     >
     > 1）对于单字节的字符，与 ASCII 码相同，第一位设置为 0；
     >
     > 2）对于多字节的字符，第一个字节的前n位都设置为1，第n + 1位统一设置为0，后面字节的前两位一律设置为10，其余二进制位全部设置为该字符的 `Unicode`码；

  4. `GBK`

     > 针对简体字的编码

     

- 一个字节对应的 bit 数，一个字节又对应几种图标



### 算法

- 给你一组数和一个数值，要你返回数值由数组内的数组合而成的所有可能，数组中的数可以无限次使用；

  ````js
  function sum(arr, target) {
      var res = []
      var temp = []
      arr.sort((a, b) => a - b)
  
      function getSum(arr) {
          let total = 0;
          for (let i = 0; i < arr.length; i++) {
              total += arr[i]
          }
          return total
      }
  
      function dfs(arr, target, index) {
          for (let i = index; i < arr.length; i++) {
              if (getSum(temp) + arr[i] < target) {
                  temp.push(arr[i])
                  while (arr[i] == arr[i + 1]) { //防止重复元素
                      i++;
                  }
                  dfs(arr, target, i)
                  temp.pop()
              } else if (getSum(temp) + arr[i] === target) {
                  temp.push(arr[i])
                  res.push(temp.slice());
                  temp.pop()
              }
          }
      }
      dfs(arr, target, 0)
      return res
  }
  
  console.log(sum([2, 3, 6, 7], 7));
  ````

  

- 通过reduce来实现map函数：

  ````js
  Array.prototype.map2 = function (fn) {
      let result = []
      this.reduce((prev, cur) => {
          result.push(fn(cur))
      }, arr[0])
      return result
  }
   
  let arr2 = arr.map2(function(item) {
      return item * 2
  })
  ````

- [最长递增子序列](https://www.nowcoder.com/jump/super-jump/word?word=最长递增子序列)意思是在一组数字中，找出最长一串递增的数字；

  

- 手写深拷贝

  

- ````js
  // 打印什么
  Promise.resolve(1)
  .then(res => {
      console.log(res)
      return 2
  })
  .then(res => {
      console.log(res)
  })
  // 1 2
  ````

  

- 手写 apply

  ````js
  Function.prototype.apply2 = apply2
   
  function apply2(obj) {
      let args = []
      let obj.fn = this
      for(let i = 0; i < arguments[1].length; i++) {
          args.push('arguments[1][' + i + ']')
      }
      let result = eval('obj.fn(' + args + ')')
      delete obj.fn
      return result
  }
   
  function f(){
      console.log(1)
  }
   
  const obj = {
   
  }
  f.apply2(obj, [2, 3, 4])
  ````

  

- 手写 Promise.all()




### 前端优化

- 网页内容

  >**减少http请求次数**
  >
  >1. 打包压缩文件，将多个样式表文件捆绑成一个文件，以此来减少文件的下载次数，比如React中使用，`npm run bulid` 形成一个 `bundle.js`；
  >2. 雪碧图；
  >3. 通过编码字符串 Base64 将图片内嵌到网页文本中；
  >
  >**减少DNS查询次数**
  >
  >DNS查询消耗响应事件，如果网页内容来自不同 `domain`，那么客户端首次解析不同的 `domain` 也要消耗一定时间，因为DNS查询结果缓存在本地系统和浏览器中一段时间，因此一般是对首次访问响应速度有影响；
  >
  >**避免页面跳转**
  >
  >当页面收到 3 开头的状态码回复重定向时，需要再次发送请求；
  >
  >**缓存Ajax**
  >
  >帮助异步下载网页，但尽量遵循以下原则提高ajax响应:
  >
  >- 添加 Expires 或 Cache-Control 报文头使回复可以被客户端缓存
  >- 压缩回复内容
  >- 减少dns查询
  >- 精简javaScript代码
  >- 避免跳转
  >- 配置Etag
  >
  >**延迟加载**
  >
  >初次只获取网页最初加载需要的最小内容集，剩下的内容推到延迟加载的集合中；
  >
  >**提前加载**
  >
  >与延迟加载相反，提前加载接下来网页中访问的内容，类似https中的服务器主动推送；
  >
  >**减少DOM元素的数量**
  >
  >`document.getElementsByTagName('*').length` 可获取网页中DOM元素的数量；
  >
  >**根据域名划分内容**
  >
  >浏览器一般争对同一个域的下载连接数有所限制，按照域名划分下载内容可以使浏览器增大并行下载连接，但域名注意控制在2-4个之间，否则影响dns查询效率；
  >
  >**避免404**
  >
  >客户端发送请求，但结果为404，浪费了请求来回时间，且当网页中需要加载一个外部脚本，结果返回404不仅阻塞其他脚本下载，下载回来的内容还会被客户端当成JavaScript解析；
  
- 服务器

  >**使用CDN**
  >
  >减少网页内容下载时间，提高下载速度还可以CDN(内容分发网络)来提升，CDN听过部署在不同地区的服务器来提高客户的下载速度；
  >
  >**添加Expires或Cache-Control报文头**
  >
  >对于静态内容添加Expires，将静态内容设置为永不过期；
  >
  >对于动态内容设置合适的Cache-Control，让浏览器根据条件发送请求；
  >
  >**Gzip压缩传输文件**
  >
  >可以减少70%网页内容的大小，包括脚本、样式表、图片等文件，且pdf文件可以从需要被压缩的类型中剔除，因为其本身以及压缩Gzip对其效果不大，且会浪费CPU；
  >
  >**配置ETags**
  >
  >类似一个文件摘要，服务器可以通过该摘要判断该请求内容是否需要更新，不用更新就回复304，从而避免下载整个文件；

